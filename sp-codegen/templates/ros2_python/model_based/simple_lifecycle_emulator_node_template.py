#----------------------------------------------------------------------------------------------------------------------#
# authors, description, version
#----------------------------------------------------------------------------------------------------------------------#
    # Endre Er{\H o}s
    # Autogenerated ROS2 emulator using jinja2 with simple lifecycle support
    # V.1.0.0.
#----------------------------------------------------------------------------------------------------------------------#

# probably should also make some config files or so that it picks up everything beside the model like timings and such
# probably the node manager will also be autogenerated since it has to pick up changes from all the nodes and
# generate interfaces to them

import sys
import rclpy
import time
from {{ package_name }}.msg import {{ message_type_node_manager_to_driver }}
from {{ package_name }}.msg import {{ message_type_driver_to_node_manager }}
from {{ package_name }}.msg import {{ message_type_driver_to_interfacer }}
from {{ package_name }}.msg import {{ message_type_interfacer_to_driver }}

SIMPLE_LIFECYCLE_STATES = [DEAD, DORMANT, ACTIVE]
SIMPLE_LIFECYCLE_COMMAND_EVENTS = [SUMMON, ACTIVATE, DEACTIVATE, KILL]
SIMPLE_LIFECYCLE_RESPONSE_EVENTS = []

class {{ resource_name }}_sp_emulator():

    def __init__(self, args=None):

        rclpy.init(args=args)

        self.node = rclpy.create_node("{{ resource_name }}_sp_emulator")
        self.msg_emulator_to_node_manager = {{ message_type_driver_to_node_manager }}()
        self.msg_node_manager_to_emulator = {{ message_type_node_manager_to_driver }}()
        self.msg_emulator_to_interfacer = {{ message_type_driver_to_interfacer }}()
        self.msg_interfacer_to_emulator = {{ message_type_interfacer_to_driver }}()

        {% for item in from_node_manager_vars %}
        self.{{ item }} = False
        {%- endfor %}
        {% for item in to_node_manager_vars %}
        self.{{ item }} = False
        {%- endfor %}

        {% for item in common_msr_vars %}
        self.{{ item }} = False
        {%- endfor %}
        {% for item in common_cmd_vars%}
        self.{{ item }} = False
        {%- endfor %}

        self.predicates = [{% for item in predicates -%}
                           '{{ item }}',
                           {% endfor -%}]

        self.actions = [{% for item in actions -%}
                        {{ item }},
                        {% endfor -%}]
        
        self.effects = [{% for item in effects -%}
                        {{ item }},
                        {% endfor -%}]

        # Message freshness definition in seconds:
        self.message_freshness = 3

        self.lifecycle_timer_period = 0.1
        self.timer_period = 0.5

        self.{{ resource_name }}_manager_sub = self.node.create_subscription({{ node_manager_to_driver_message_type }}, 
                                                                        "/{{ resource_name }}_node_manager_to_driver", 
                                                                        self.{{ resource_name }}_node_manager_to_driver_callback, 10)
        self.{{ resource_name }}_manager_pub = self.node.create_publisher({{ driver_to_node_manager_message_type }}, 
                                                                        "/{{ resource_name }}_driver_to_node_manager", 10)
        
        self.lifecycle_tmr = self.node.create_timer(self.lifecycle_timer_period, self.driver_to_node_manager_callback)

        rclpy.spin(self.node)
        self.node.destroy_node()
        rclpy.shutdown()
    


    def interfacer_to_driver_timer_start(self):
        # Start the timer when a message arrives.
        self.int_to_driv_timer_start = time.time()
        return self.int_to_driv_timer_start

    def interfacer_to_driver_timer_elapsed(self):
        # Measure elapsed time since the last message arrived.
        return time.time() - self.int_to_driv_timer_start

    def node_manager_to_driver_timer_start(self):
        # Start the timer when a message arrives from the node manager.
        self.node_mng_to_driv_timer_start = time.time()
        return self.node_mng_to_driv_timer_start

    def node_mng_to_driver_timer_elapsed(self):
        # Measure elapsed time since the last message arrived.
        return time.time() - self.node_mng_to_driv_timer_start


    def node_manager_to_driver_callback(self, lifecycle_msg):
        # should probably be event based, so only one message, or even could be a service?? no not really

        # Check message freshness:
        if time.time() < self.node_manager_to_driver_callback_timeout:
            self.interfacer_to_driver_msg_is_fresh = True
        else:
            self.interfacer_to_driver_msg_is_fresh = False

        if lifecycle_msg.data == "summon":
            pass # probably the future node_managers thing to do
            # node dead untill it's summoned and first dormant message arrives
        elif lifecycle_msg.data == "activate":
            self.activate_node()
        elif lifecycle_msg.data == "deactivate":
            self.deactiavte_node()
        elif lifecycle_msg.data == "kill":
            self.autokill() # Or maybe kill from node manager
        else:
            pass # Print some error thingy here or catch exception

    def driver_to_node_manager_callback(self):

    
    def activate_node(self):
        self.{{ resource_name }}_interfacer_sub = self.node.create_subscription({{ message_type_interfacer_to_driver }}, 
                                                                        "/{{ resource_name }}_interfacer_to_driver", 
                                                                        self.{{ resource_name }}_interfacer_to_driver_callback, 10)
        self.{{ resource_name }}_interfacer_pub = self.node.create_publisher({{ message_type_driver_to_interfacer }}, 
                                                                        "/{{ resource_name }}_driver_to_interfacer", 10)

        self.main_tmr = self.node.create_timer(self.timer_period, self.main_callback)

    def deactiavte_node(self):
        # Probably have to look into the method names for destruction
        self.{{ resource_name }}_interfacer_sub.remove_subsription()
        self.{{ resource_name }}_interfacer_pub.remove_publisher()   

    def autokill(self):
        # Also probably have to look at how this cleans up stuff
        self.node.destroy_node()
        rclpy.shutdown()

    def {{ resource_name }}_interfacer_to_driver_callback(self, data):
        
        self.interfacer_to_driver_callback_timeout = time.time() + self.message_freshness
        self.interfacer_to_driver_timer_start()

        {% for item in cmd_vars %}
        self.{{ item }} = data.{{ item }}
        self.msg_emulator_to_interfacer.got_{{ item }} = self.{{ item }}
        {%- endfor %}

    # try to test this with a really big example and also with alternative effects
    # could be goot to maybe include somewhere in the future some probablities
    # to extend this to Markov Chains (or markov descision processes)

    def main_callback(self):
        store_eval_indexes = []
        for pred in range(len(self.predicates)):
            if eval(self.predicates[pred]):
                store_eval_indexes.append(pred)
        
        print(store_eval_indexes)

        for store_eval_index in store_eval_indexes:
            for effect in self.effects[store_eval_index]:
                print(effect)
                exec(effect)
        
        {% for item in msr_vars %}
        self.msg_emulator_to_interfacer.{{ item }} = self.{{ item }}
        {%- endfor %}

        self.{{ resource_name }}_interfacer_pub.publish(self.msg_emulator_to_interfacer)

if __name__ == '__main__':
    {{ resource_name }}_sp_emulator()
