#----------------------------------------------------------------------------------------------------------------------#
# authors, description, version
#----------------------------------------------------------------------------------------------------------------------#
    # Endre Er{\H o}s
    # Autogenerated ROS2 {{ resource_name }} simple lifecycle interfacer node using jinja2
    # V.1.0.0.
#----------------------------------------------------------------------------------------------------------------------#

import sys
import rclpy
import time
from rclpy.node import Node
from {{ package_name }}.msg import {{ message_type_controller_to_interfacer }}
from {{ package_name }}.msg import {{ message_type_interfacer_to_controller }}
from {{ package_name }}.msg import {{ message_type_driver_to_interfacer }}
from {{ package_name }}.msg import {{ message_type_interfacer_to_driver }}
from {{ package_name }}.msg import {{ message_type_node_manager_to_interfacer }}
from {{ package_name }}.msg import {{ message_type_interfacer_to_node_manager }}

class {{ capitalized_resource_name }}SimpleLifecycleInterfacer(Node):
    """ The Interfacer node acts as an intermediary between a high level controller and endpoint nodes (emulator,
    simulator, driver). The purpose is to standardize the interface between the higher level controller and endpoint
    nodes so that the controller doesn't have to care with whom it is communicating. This simple lifecycle version of 
    the Interfacer node has it's internal state (dead, dormant, active) which can be managed by the Node Manager. """

    def __init__(self):
        super().__init__("{{ resource_name }}_simple_lifecycle_interfacer")

        self.msg_controller_to_interfacer = {{ message_type_controller_to_interfacer }}()
        self.msg_interfacer_to_controller = {{ message_type_interfacer_to_controller }}()
        self.msg_driver_to_interfacer = {{ message_type_driver_to_interfacer }}()
        self.msg_interfacer_to_driver = {{ message_type_interfacer_to_driver }}()
        self.msg_node_manager_to_interfacer = {{ message_type_node_manager_to_interfacer }}()
        self.msg_interfacer_to_node_manager = {{ message_type_interfacer_to_node_manager }}()

        self.interfacer_to_controller_tmr_period = 0.5
        self.interfacer_to_driver_tmr_period = 0.5
        self.interfacer_to_node_manager_tmr_period = 0.5

        # Be careful what init values are since they are being published immediately when  the node is up!
        self.node_state = "DORMANT"

        {% for item in measured_variables %}
        self.{{ item }} = False
        {%- endfor %}
        {% for item in command_variables %}
        self.{{ item }} = False
        self.got_{{ item }} = False
        {%- endfor %}

        # This subscriber listens to the node manager in order to change the state od the node
        self.{{ resource_name }}_node_manager_to_interfacer_subscriber = self.create_subscription(
            {{ message_type_node_manager_to_interfacer }},
            "/{{ resource_name }}_node_manager_to_interfacer",
            self.{{ resource_name }}_node_manager_to_interfacer_callback,
            10)

        # Then sleep for a bit so that the node get the updated variables before publishing them
        time.sleep(2)

        # This publisher reports the node state to the node manager
        self.{{ resource_name }}_interfacer_to_node_manager_publisher_ = self.create_publisher(
            {{ message_type_interfacer_to_node_manager }},
            "/{{ resource_name }}_interfacer_to_node_manager",
            10)

        self.interfacer_to_node_manager_tmr = self.create_timer(
            self.interfacer_to_node_manager_tmr_period, 
            self.interfacer_to_node_manager_publisher_callback)


    def activate_node(self):
        """ Activates the node on command from the Node Manager by starting the subscribers and publishers. """

        # Start the subscribers first so that they possibly update the variables
        self.{{ resource_name }}_controller_to_interfacer_subscriber = self.create_subscription(
            {{ message_type_controller_to_interfacer }}, 
            "/{{ resource_name }}_controller_to_interfacer",
            self.{{ resource_name }}_controller_to_interfacer_callback,
            10)

        self.{{ resource_name }}_driver_to_interfacer_subscriber = self.create_subscription(
            {{ message_type_driver_to_interfacer }},
            "/{{ resource_name }}_driver_to_interfacer",
            self.{{ resource_name }}_driver_to_interfacer_callback,
            10)

        # Then sleep for a bit so that the node get the updated variables before publishing them
        time.sleep(2)

        self.{{ resource_name }}_interfacer_to_controller_publisher_ = self.create_publisher(
            {{ message_type_interfacer_to_controller }},
            "/{{ resource_name }}_interfacer_to_controller",
            10)

        self.{{ resource_name }}_interfacer_to_driver_publisher_ = self.create_publisher(
            {{ message_type_interfacer_to_driver }},
            "/{{ resource_name }}_interfacer_to_driver",
            10)
    
        # Decoupled message receiving and forwarding
        self.interfacer_to_controller_tmr = self.create_timer(
            self.interfacer_to_controller_tmr_period, 
            self.interfacer_to_controller_publisher_callback)

        self.interfacer_to_driver_tmr = self.create_timer(
            self.interfacer_to_driver_tmr_period, 
            self.interfacer_to_driver_publisher_callback)


    def deactivate_node(self):
        """ Deactivates the node on command from the Node Manager by destroying publishers and subscribers. """
        
        # First destroy the publishers so that they don't publish garbage
        self.destroy_publisher(self.{{ resource_name }}_interfacer_to_controller_publisher_)
        self.destroy_publisher(self.{{ resource_name }}_interfacer_to_driver_publisher_)

        self.destroy_subscription(self.{{ resource_name }}_controller_to_interfacer_subscriber)
        self.destroy_subscription(self.{{ resource_name }}_driver_to_interfacer_subscriber)


    def kill_node(self):
        """ Destroys the node on command from the Node Manager. """

        {{ resource_name }}_simple_lifecycle_interfacer.destroy_node()
        rclpy.shutdown()
        

    def presence_timer_start(self):
        """ Start the timer when the node changes state from DEAD to DORMANT. """

        self.presence_time = time.time()
        return self.presence_time


    def presence_timer_elapsed(self):
        """ Measure elapsed time since the node has changed state from DEAD to DORMANT. """

        return str(time.time() - self.presence_time)


    def activation_timer_start(self):
        """ Start the timer when the node changes state from DORMANT to ACTIVE. """
        
        self.activation_time = time.time()
        return self.activation_time


    def activation_timer_elapsed(self):
        """ Measure elapsed time since the node has changed state from DORMANT to ACTIVE. """

        return str(time.time() - self.activation_time)


    def deactivation_timer_start(self):
        """ Start the timer when the node changes state from ACTIVE to DORMANT. """
        
        self.deactivation_time = time.time()
        return self.deactivation_time


    def deactivation_timer_elapsed(self):
        """ Measure elapsed time since the node has changed state from ACTIVE to DORMANT. """

        return str(time.time() - self.deactivation_time)


    def controller_to_interfacer_timer_start(self):
        """ Start the timer when a message arrives from the controller."""

        self.controller_to_interfacer_time = time.time()
        return self.controller_to_interfacer_time


    def controller_to_interfacer_timer_elapsed(self):
        """ Measure elapsed time since the last message arrived from the controller """

        return time.time() - self.controller_to_interfacer_time


    def driver_to_interfacer_timer_start(self):
        """ Start the timer when a message arrives from the driver. """

        self.int_to_driv_timer_start = time.time()
        return self.int_to_driv_timer_start


    def driver_to_interfacer_timer_elapsed(self):
        """ Measure elapsed time since the last message arrived from the driver. """

        return time.time() - self.int_to_driv_timer_start


    def node_manager_to_interfacer_timer_start(self):
        """ Start the timer when a message arrives from the node manager. """

        self.node_mng_to_driv_timer_start = time.time()
        return self.node_mng_to_driv_timer_start


    def node_manager_to_interfacer_timer_elapsed(self):
        """ Measure elapsed time since the last message arrived from the node manager. """

        return time.time() - self.node_mng_to_driv_timer_start


    def {{ resource_name }}_controller_to_interfacer_callback(self, data):
        """ Forwarding messages from the controller to the endpoint nodes. """
        {% for item in command_variables %}
        self.{{ item }} = data.{{ item }}
        self.msg_interfacer_to_driver.{{ item }} = self.{{ item }}
        {%- endfor %}
        self.{{ resource_name }}_interfacer_to_driver_publisher_.publish(self.msg_interfacer_to_driver)

    def {{ resource_name }}_driver_to_interfacer_callback(self, data):
        """ Forwarding messages from the endpoint nodes to the controllers. """
        {% for item in measured_variables %}
        self.{{ item }} = data.{{ item }}
        self.msg_interfacer_to_controller.{{ item }} = self.{{ item }}
        {%- endfor %}
        {% for item in command_variables %}
        self.msg_interfacer_to_controller.got_{{ item }} = self.got_{{ item }}
        {%- endfor %}

        self.{{ resource_name }}_interfacer_to_controller_publisher_.publish(self.msg_interfacer_to_controller)

def main(args=None):
    rclpy.init(args=args)

    {{ resource_name }}_interfacer = {{ capitalized_resource_name }}SimpleLifecycleInterfacer()

    rclpy.spin({{ resource_name }}_simple_lifecycle_interfacer)

    {{ resource_name }}_simple_lifecycle_interfacer.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()