#----------------------------------------------------------------------------------------------------------------------#
# authors, description, version
#----------------------------------------------------------------------------------------------------------------------#
    # Endre Er{\H o}s
    # SP model based Autogenerated ROS2 {{ resource_name }} emulator node using jinja2
    # V.1.0.2.
#----------------------------------------------------------------------------------------------------------------------#

import sys
import rclpy
import time
import random
from rclpy.node import Node
from {{ package_name }}_msgs.msg import {{ message_type_interfacer_to_driver }}
from {{ package_name }}_msgs.msg import {{ message_type_driver_to_interfacer }}

class {{ capitalized_resource_name }}Emulator(Node):

    def __init__(self):
        super().__init__("{{ resource_name }}_emulator")
        
        self.msg_emulator_to_interfacer = {{ message_type_driver_to_interfacer }}()
        self.msg_interfacer_to_emulator = {{ message_type_interfacer_to_driver }}()

        self.emulator_to_interfacer_tmr_period = 0.5

        # Be careful what init values are since they are being published immediately the node is up!
        {% for item in measured_variables %}
        self.{{ item }} = False
        {%- endfor %}
        {% for item in command_variables %}
        self.{{ item }} = False
        self.got_{{ item }} = False
        {%- endfor %}     

        # Predicates
        {% for item in predicates -%}
        {{ item }}
        {% endfor -%}

        # Transitions
        self.transitions = [{% for item in transitions -%}
                        {{ item }},
                        {% endfor -%}]
        
        # Could be good to start the subscribers first so that they update the variables if other nodes are up
        self.{{ resource_name }}_interfacer_to_emulator_subscriber = self.create_subscription(
            {{ message_type_interfacer_to_driver }}, 
            "/{{ resource_name }}_interfacer_to_driver",
            self.{{ resource_name }}_interfacer_to_emulator_callback,
            10)

        # Then sleep for a bit so that the node get the updated variables before publishing them
        time.sleep(2)

        self.{{ resource_name }}_emulator_to_interfacer_publisher_ = self.create_publisher(
            {{ message_type_driver_to_interfacer }},
            "/{{ resource_name }}_driver_to_interfacer",
            10)

        self.emulator_to_interfacer_tmr = self.create_timer(
            self.emulator_to_interfacer_tmr_period, 
            self.emulator_to_interfacer_publisher_callback)
 
    # SP updating the command variables through the interfacer
    def {{ resource_name }}_interfacer_to_emulator_callback(self, data):
        {% for item in command_variables %}
        self.{{ item }} = data.{{ item }}
        self.msg_emulator_to_interfacer.got_{{ item }} = data.{{ item }}
        {%- endfor %}

    def emulator_to_interfacer_publisher_callback(self):
        store_eval_indexes = []
        for pred in range(len(self.transitions)):
            if eval(self.transitions[pred][0]):
                store_eval_indexes.append(pred)
        
        print(store_eval_indexes)

        for store_eval_index in store_eval_indexes:
            for effect in self.transitions[store_eval_index][2]:
                print(effect)
                exec(effect)
        
        {% for item in measured_variables %}
        self.msg_emulator_to_interfacer.{{ item }} = self.{{ item }}
        {%- endfor %}

        self.{{ resource_name }}_emulator_to_interfacer_publisher_.publish(self.msg_emulator_to_interfacer)

def main(args=None):
    rclpy.init(args=args)

    {{ resource_name }}_emulator = {{ capitalized_resource_name }}Emulator()

    rclpy.spin({{ resource_name }}_emulator)

    {{ resource_name }}_emulator.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()