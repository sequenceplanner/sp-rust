#----------------------------------------------------------------------------------------------------------------------#
# authors, description, version
#----------------------------------------------------------------------------------------------------------------------#
    # Endre Er{\H o}s
    # SP model based Autogenerated ROS2 door1 interfacer node using jinja2
    # V.1.0.2.
#----------------------------------------------------------------------------------------------------------------------#

import sys
import rclpy
import time
from rclpy.node import Node
from macro_test_gen1.msg import Door1SPToInterfacer
from macro_test_gen1.msg import Door1InterfacerToSP
from macro_test_gen1.msg import Door1DriverToInterfacer
from macro_test_gen1.msg import Door1InterfacerToDriver

class Door1Interfacer(Node):

    def __init__(self):
        super().__init__("door1_interfacer")

        self.msg_sp_to_interfacer = Door1SPToInterfacer()
        self.msg_interfacer_to_sp = Door1InterfacerToSP()
        self.msg_driver_to_interfacer = Door1DriverToInterfacer()
        self.msg_interfacer_to_driver = Door1InterfacerToDriver()

        self.interfacer_to_sp_tmr_period = 0.5
        self.interfacer_to_driver_tmr_period = 0.5

        # Be careful what init values are since they are being published immediately the node is up!
        
        self.closed_m = False
        self.opened_m = False
        
        self.opened_c = False
        self.got_opened_c = False
        self.closed_c = False
        self.got_closed_c = False

        # Could be good to start the subscribers first so that they update the variables if other nodes are up
        self.door1_sp_to_interfacer_subscriber = self.create_subscription(
            Door1SPToInterfacer, 
            "/door1_sp_to_interfacer",
            self.door1_sp_to_interfacer_callback,
            10)

        self.door1_driver_to_interfacer_subscriber = self.create_subscription(
            Door1DriverToInterfacer,
            "/door1_driver_to_interfacer",
            self.door1_driver_to_interfacer_callback,
            10)

        # Then sleep for a bit so that the node get the updated variables before publishing them
        time.sleep(2)

        self.door1_interfacer_to_sp_publisher_ = self.create_publisher(
            Door1InterfacerToSP,
            "/door1_interfacer_to_sp",
            10)

        self.door1_interfacer_to_driver_publisher_ = self.create_publisher(
            Door1InterfacerToDriver,
            "/door1_interfacer_to_driver",
            10)
    
        # Decouple message receiving and forwarding
        self.interfacer_to_sp_tmr = self.create_timer(
            self.interfacer_to_sp_tmr_period, 
            self.interfacer_to_sp_publisher_callback)

        self.interfacer_to_driver_tmr = self.create_timer(
            self.interfacer_to_driver_tmr_period, 
            self.interfacer_to_driver_publisher_callback)

    # Publish init values of vars to SP or publish the latest received from the driver
    def interfacer_to_sp_publisher_callback(self):
        
        self.msg_interfacer_to_sp.closed_m = self.closed_m
        self.msg_interfacer_to_sp.opened_m = self.opened_m
        
        self.msg_interfacer_to_sp.got_opened_c = self.got_opened_c
        self.msg_interfacer_to_sp.got_closed_c = self.got_closed_c

        self.door1_interfacer_to_sp_publisher_.publish(self.msg_interfacer_to_sp)

    # Publish init values of vars to the driver node or the latest receive cmd from SP
    def interfacer_to_driver_publisher_callback(self):
        
        self.msg_interfacer_to_driver.opened_c = self.opened_c
        self.msg_interfacer_to_driver.closed_c = self.closed_c

        self.door1_interfacer_to_driver_publisher_.publish(self.msg_interfacer_to_driver)

    # SP updating the command variables
    def door1_sp_to_interfacer_callback(self, data):
        
        self.opened_c = data.opened_c
        self.msg_interfacer_to_driver.opened_c = self.opened_c
        self.closed_c = data.closed_c
        self.msg_interfacer_to_driver.closed_c = self.closed_c

    # Driver updating the measured variables
    def door1_driver_to_interfacer_callback(self, data):
        
        self.closed_m = data.closed_m
        self.opened_m = data.opened_m
        
        self.got_opened_c = data.got_opened_c
        self.got_closed_c = data.got_closed_c

def main(args=None):
    rclpy.init(args=args)

    door1_interfacer = Door1Interfacer()

    rclpy.spin(door1_interfacer)

    door1_interfacer.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()