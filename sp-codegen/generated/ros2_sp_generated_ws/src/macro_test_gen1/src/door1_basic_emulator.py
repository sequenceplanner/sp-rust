#----------------------------------------------------------------------------------------------------------------------#
# authors, description, version
#----------------------------------------------------------------------------------------------------------------------#
    # Endre Er{\H o}s
    # SP model based Autogenerated ROS2 door1 emulator node using jinja2
    # V.1.0.2.
#----------------------------------------------------------------------------------------------------------------------#

import sys
import rclpy
import time
import random
from rclpy.node import Node
from macro_test_gen1_msgs.msg import Door1InterfacerToDriver
from macro_test_gen1_msgs.msg import Door1DriverToInterfacer

class Door1Emulator(Node):

    def __init__(self):
        super().__init__("door1_emulator")
        
        self.msg_emulator_to_interfacer = Door1DriverToInterfacer()
        self.msg_interfacer_to_emulator = Door1InterfacerToDriver()

        self.emulator_to_interfacer_tmr_period = 0.5

        # Be careful what init values are since they are being published immediately the node is up!
        
        self.opened_m = False
        self.closed_m = False
        
        self.closed_c = False
        self.got_closed_c = False
        self.opened_c = False
        self.got_opened_c = False     

        # Predicates
        self.open_enabled = not self.opened_c and not self.opened_m
        self.open_executing = self.opened_c and not self.opened_m
        self.open_finishing = self.opened_c and self.opened_m
        self.open_done = not self.opened_c and self.opened_m
        self.close_enabled = not self.closed_c and not self.closed_m
        self.close_executing = self.closed_c and not self.closed_m
        self.close_finishing = self.closed_c and self.closed_m
        self.close_done = not self.closed_c and self.closed_m
        # Transitions
        self.transitions = [(self.open_enabled, ['self.opened_c = True'], []),
                        (self.open_executing, [], ['self.opened_m = True']),
                        (self.open_finishing, ['self.opened_c = False'], []),
                        (self.close_enabled, ['self.closed_c = True'], []),
                        (self.close_executing, [], ['self.closed_m = True']),
                        (self.close_finishing, ['self.closed_c = False'], []),
                        ]
        
        # Could be good to start the subscribers first so that they update the variables if other nodes are up
        self.door1_interfacer_to_emulator_subscriber = self.create_subscription(
            Door1InterfacerToDriver, 
            "/door1_interfacer_to_driver",
            self.door1_interfacer_to_emulator_callback,
            10)

        # Then sleep for a bit so that the node get the updated variables before publishing them
        time.sleep(2)

        self.door1_emulator_to_interfacer_publisher_ = self.create_publisher(
            Door1DriverToInterfacer,
            "/door1_driver_to_interfacer",
            10)

        self.emulator_to_interfacer_tmr = self.create_timer(
            self.emulator_to_interfacer_tmr_period, 
            self.emulator_to_interfacer_publisher_callback)
 
    # SP updating the command variables through the interfacer
    def door1_interfacer_to_emulator_callback(self, data):
        
        self.closed_c = data.closed_c
        self.msg_emulator_to_interfacer.got_closed_c = data.closed_c
        self.opened_c = data.opened_c
        self.msg_emulator_to_interfacer.got_opened_c = data.opened_c

    def emulator_to_interfacer_publisher_callback(self):
        store_eval_indexes = []
        for pred in range(len(self.transitions)):
            if eval(self.transitions[pred][0]):
                store_eval_indexes.append(pred)
        
        print(store_eval_indexes)

        for store_eval_index in store_eval_indexes:
            for effect in self.transitions[store_eval_index][2]:
                print(effect)
                exec(effect)
        
        
        self.msg_emulator_to_interfacer.opened_m = self.opened_m
        self.msg_emulator_to_interfacer.closed_m = self.closed_m

        self.door1_emulator_to_interfacer_publisher_.publish(self.msg_emulator_to_interfacer)

def main(args=None):
    rclpy.init(args=args)

    door1_emulator = Door1Emulator()

    rclpy.spin(door1_emulator)

    door1_emulator.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()